
data Pair a b =
  | Pair a b

data Sum a b =
  | Inl a
  | Inr b

val nand : Bool → Bool → Bool
let nand = λx. λy. ¬ (x ∧ y)

val xor : Bool → Bool → Bool
let xor = λx. λy. if x then ¬ y else y

val xnor : Bool → Bool → Bool
let xnor = λx. λy. ¬ (xor x y)

val succ : ℤ → ℤ
let succ = λx. x + 1

val pred : ℤ → ℤ
let pred = λx. x - 1

val proj1 : a × b → a
let proj1 = λp. p₁

val proj2 : a × b → b
let proj2 = λp. p₂

val double : a → a × a
let double = λx. (x, x)

# Force evaluation of the argument and return unit.
val seq : a → Unit
let seq = λ_. tt

# Function composition.
val compose : (a → b) → (b → c) → a → c
let compose = λf. λg. λx. g (f x)

# Function tupling.
val tuple : (a → b) → (a → c) → a → b × c
let tuple = λf. λg. λx. (f x, g x)

val pair_fun : (a → c) → (b → d) → a × b → c × d
let pair_fun = λf. λg. λp. (f p₁, g p₂)

# This should be equivalent to the above.
# let pair_fun = λf. λg. ⟨f ∘ π₁, g ∘ π₂⟩

# Function cotupling.
val cotuple : (a → c) → (b → c) → a + b → c
let cotuple = λf. λg. λs.
  destruct s as
  | Inl x → f x
  | Inr y → g y

val curry : (a × b → c) → a → b → c
let curry = λf. λx. λy. f (x, y)

val uncurry : (a → b → c) → a × b → c
let uncurry = λf. λp. f p₁ p₂

val eval : (a → b) → a → b
let eval = λf. λx. f x

# Exponentiation
val pow : ℤ → ℤ → ℤ
letrec pow = λn. λm.
  if m ≤ 0 then 1 else
  n * pow n (m - 1)

# Factorial
val fact : ℤ → ℤ
letrec fact = λn.
  if n ≤ 0 then 1 else
  n * fact (n - 1)
