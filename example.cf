∃ prelude

# \Bbb{Z}

val towardzero : ℤ → ℤ
letrec towardzero = λn.
  if n > 0 then n - 1 else
  if n < 0 then n + 1 else
  0

val even : ℤ → Bool
letrec even = λn. if n = 0 then ⊤ else ¬ even (towardzero n)

val odd : ℤ → Bool
let odd = λx. ¬ even x

let intToBool = λx. if x = 0 then ⊥ else ⊤

let x1 = inl 0 : ℤ + Bool
let x2 = inr ⊥ : ℤ + Bool

val x3 : ℤ + Bool -> Bool
let x3 = case x1 of
     | inl x → intToBool x
     | inr y → y

let counter = ref -1

val dontimes : (Unit → Unit) → ℤ → Unit
letrec dontimes = λf. λn.
  if n = 0 then tt else
  (f tt; dontimes f (n - 1))

val incn : ℤ → Unit
let incn = μ (λg. λn.
             if n = 0 then tt else
	       (counter ← !counter + 1; g (n - 1)))

〚 dontimes (\_. counter ← !counter + 1) 10 〛
〚 incn 10 〛

〚 counter ← !counter + 1 〛
〚 counter ← !counter + 1 〛

val f : (a → b) → ℤ
let f = λ_. 0

〚 f f 〛

val g : a → a
let g = λx. x

val triangle : ℤ → ℤ
letrec triangle = λn. if n = 0 then 0 else n + triangle (n - 1)

〚 dontimes (λ_. counter ← !counter + 1)
            (let x = 5 in triangle (100 + x)) 〛
   # seq (!counter);
   # fact 10 〛

# val f : ℤ → ℤ
# let f = λx. x + 5

# val g : ℤ → ℤ
# let g = λx. x * 2

# val h : ℤ × ℤ → ℤ × ℤ
# let h = ⟨f ∘ π₁, g ∘ π₂⟩
# # let h = tuple (compose fst f) (compose snd g)
# # let h = ⟨f, g⟩

# val x : ℤ × ℤ
# let x = (1, 2)


# # 〚 (f ∘ π₁) x 〛
# 〚 compose f π₁ 〛

val f : ℤ → Bool
let f = λx:Int. if x = 0 then ⊥ else ⊤

val g : Bool → Unit
let g = λ_:Bool. tt

# let compose = λf. λg. λx. g (f x)

# There is a bug in the typechecker. It lets the following program
# through which leads to a runtime error.
# 〚 (λf. λg. λx. g (f x)) g f 0 〛
〚 compose g f 0 〛

# (((λf. λg. λx. g (f x)) g) f) 0   has type X

# ((λf. λg. λx. g (f x)) g) f   should be Int -> X

# (λf. λg. λx. g (f x)) g   should be (Int -> Bool) -> (Int -> X)

# λg. λf. λx. f (g x))   should be (Bool -> Unit) -> ((Int -> Bool) -> (Int -> X))

# λf. λx. f (g x))   should be (Int -> Bool) -> (Int -> X)

# λx. f (g x))   should be Int -> X

# f (g x))   should be Int -> X